{"version":3,"sources":["main.js"],"names":["OrbitControls","EventDispatcher","object","domElement","offset","quat","quatInverse","lastPosition","lastQuaternion","twoPI","undefined","console","warn","document","error","enabled","target","Vector3","minDistance","maxDistance","Infinity","minZoom","maxZoom","minPolarAngle","maxPolarAngle","Math","PI","minAzimuthAngle","maxAzimuthAngle","enableDamping","dampingFactor","enableZoom","zoomSpeed","enableRotate","rotateSpeed","enablePan","panSpeed","screenSpacePanning","keyPanSpeed","autoRotate","autoRotateSpeed","keys","LEFT","UP","RIGHT","BOTTOM","mouseButtons","MOUSE","ROTATE","MIDDLE","DOLLY","PAN","touches","ONE","TOUCH","TWO","DOLLY_PAN","target0","clone","position0","position","zoom0","zoom","_domElementKeyEvents","getPolarAngle","spherical","phi","getAzimuthalAngle","theta","listenToKeyEvents","addEventListener","onKeyDown","saveState","scope","copy","reset","updateProjectionMatrix","dispatchEvent","_changeEvent","update","state","STATE","NONE","Quaternion","setFromUnitVectors","up","invert","sub","applyQuaternion","setFromVector3","rotateLeft","sphericalDelta","min","max","zoomChanged","isFinite","makeSafe","radius","scale","addScaledVector","panOffset","add","setFromSpherical","lookAt","multiplyScalar","set","distanceToSquared","EPS","dot","quaternion","dispose","removeEventListener","onContextMenu","onPointerDown","onMouseWheel","onTouchStart","onTouchEnd","onTouchMove","ownerDocument","onPointerMove","onPointerUp","TOUCH_ROTATE","TOUCH_PAN","TOUCH_DOLLY_PAN","TOUCH_DOLLY_ROTATE","Spherical","rotateStart","Vector2","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","getZoomScale","pow","angle","rotateUp","panLeft","v","distance","objectMatrix","setFromMatrixColumn","panUp","crossVectors","pan","deltaX","deltaY","element","isPerspectiveCamera","targetDistance","length","tan","fov","clientHeight","matrix","isOrthographicCamera","right","left","clientWidth","top","bottom","dollyOut","dollyScale","dollyIn","handleMouseDownRotate","event","clientX","clientY","handleMouseDownPan","handleTouchStartRotate","pageX","pageY","x","y","handleTouchStartPan","handleTouchStartDolly","dx","dy","sqrt","handleTouchMoveRotate","subVectors","handleTouchMovePan","handleTouchMoveDolly","pointerType","onMouseDown","mouseAction","preventDefault","focus","window","button","handleMouseDownDolly","ctrlKey","metaKey","shiftKey","_startEvent","onMouseMove","handleMouseMoveRotate","handleMouseMoveDolly","handleMouseMovePan","onMouseUp","_endEvent","handleMouseWheel","handleKeyDown","needsUpdate","code","handleTouchStartDollyPan","DOLLY_ROTATE","handleTouchStartDollyRotate","handleTouchMoveDollyPan","handleTouchMoveDollyRotate","passive","log","dat","raycaster","THREE","Raycaster","scene","Scene","camera","PerspectiveCamera","innerWidth","innerHeight","renderer","WebGLRenderer","generatePlane","planeMesh","geometry","PlaneGeometry","world","plane","width","height","widthSegments","heightSegments","array","attributes","randomValues","i","z","random","push","originalPosition","colors","count","setAttribute","BufferAttribute","Float32Array","setSize","setPixelRatio","devicePixelRatio","gui","GUI","onChange","body","appendChild","controls","planeGeometry","planeMaterial","MeshPhongMaterial","side","DoubleSide","flatShading","FlatShading","vertexColors","Mesh","light","DirectionalLight","backlight","mouse","frame","animate","requestAnimationFrame","render","setFromCamera","cos","sin","intersects","intersectObject","color","setX","face","a","setY","b","setZ","c","initialColor","r","g","hoverColor","gsap","to","duration","onUpdate"],"mappings":"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","file":"main.fda3fea7.js","sourceRoot":"..","sourcesContent":["class OrbitControls extends EventDispatcher {\n\n    constructor(object, domElement) {\n\n        super();\n\n        if (domElement === undefined) console.warn('THREE.OrbitControls: The second parameter \"domElement\" is now mandatory.');\n        if (domElement === document) console.error('THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.');\n\n        this.object = object;\n        this.domElement = domElement;\n\n        // Set to false to disable this control\n        this.enabled = true;\n\n        // \"target\" sets the location of focus, where the object orbits around\n        this.target = new Vector3();\n\n        // How far you can dolly in and out ( PerspectiveCamera only )\n        this.minDistance = 0;\n        this.maxDistance = Infinity;\n\n        // How far you can zoom in and out ( OrthographicCamera only )\n        this.minZoom = 0;\n        this.maxZoom = Infinity;\n\n        // How far you can orbit vertically, upper and lower limits.\n        // Range is 0 to Math.PI radians.\n        this.minPolarAngle = 0; // radians\n        this.maxPolarAngle = Math.PI; // radians\n\n        // How far you can orbit horizontally, upper and lower limits.\n        // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n        this.minAzimuthAngle = - Infinity; // radians\n        this.maxAzimuthAngle = Infinity; // radians\n\n        // Set to true to enable damping (inertia)\n        // If damping is enabled, you must call controls.update() in your animation loop\n        this.enableDamping = false;\n        this.dampingFactor = 0.05;\n\n        // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n        // Set to false to disable zooming\n        this.enableZoom = true;\n        this.zoomSpeed = 1.0;\n\n        // Set to false to disable rotating\n        this.enableRotate = true;\n        this.rotateSpeed = 1.0;\n\n        // Set to false to disable panning\n        this.enablePan = true;\n        this.panSpeed = 1.0;\n        this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n        this.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n        // Set to true to automatically rotate around the target\n        // If auto-rotate is enabled, you must call controls.update() in your animation loop\n        this.autoRotate = false;\n        this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n\n        // The four arrow keys\n        this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };\n\n        // Mouse buttons\n        this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };\n\n        // Touch fingers\n        this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };\n\n        // for reset\n        this.target0 = this.target.clone();\n        this.position0 = this.object.position.clone();\n        this.zoom0 = this.object.zoom;\n\n        // the target DOM element for key events\n        this._domElementKeyEvents = null;\n\n        //\n        // public methods\n        //\n\n        this.getPolarAngle = function () {\n\n            return spherical.phi;\n\n        };\n\n        this.getAzimuthalAngle = function () {\n\n            return spherical.theta;\n\n        };\n\n        this.listenToKeyEvents = function (domElement) {\n\n            domElement.addEventListener('keydown', onKeyDown);\n            this._domElementKeyEvents = domElement;\n\n        };\n\n        this.saveState = function () {\n\n            scope.target0.copy(scope.target);\n            scope.position0.copy(scope.object.position);\n            scope.zoom0 = scope.object.zoom;\n\n        };\n\n        this.reset = function () {\n\n            scope.target.copy(scope.target0);\n            scope.object.position.copy(scope.position0);\n            scope.object.zoom = scope.zoom0;\n\n            scope.object.updateProjectionMatrix();\n            scope.dispatchEvent(_changeEvent);\n\n            scope.update();\n\n            state = STATE.NONE;\n\n        };\n\n        // this method is exposed, but perhaps it would be better if we can make it private...\n        this.update = function () {\n\n            const offset = new Vector3();\n\n            // so camera.up is the orbit axis\n            const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));\n            const quatInverse = quat.clone().invert();\n\n            const lastPosition = new Vector3();\n            const lastQuaternion = new Quaternion();\n\n            const twoPI = 2 * Math.PI;\n\n            return function update() {\n\n                const position = scope.object.position;\n\n                offset.copy(position).sub(scope.target);\n\n                // rotate offset to \"y-axis-is-up\" space\n                offset.applyQuaternion(quat);\n\n                // angle from z-axis around y-axis\n                spherical.setFromVector3(offset);\n\n                if (scope.autoRotate && state === STATE.NONE) {\n\n                    rotateLeft(getAutoRotationAngle());\n\n                }\n\n                if (scope.enableDamping) {\n\n                    spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n                    spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n\n                } else {\n\n                    spherical.theta += sphericalDelta.theta;\n                    spherical.phi += sphericalDelta.phi;\n\n                }\n\n                // restrict theta to be between desired limits\n\n                let min = scope.minAzimuthAngle;\n                let max = scope.maxAzimuthAngle;\n\n                if (isFinite(min) && isFinite(max)) {\n\n                    if (min < - Math.PI) min += twoPI; else if (min > Math.PI) min -= twoPI;\n\n                    if (max < - Math.PI) max += twoPI; else if (max > Math.PI) max -= twoPI;\n\n                    if (min <= max) {\n\n                        spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n\n                    } else {\n\n                        spherical.theta = (spherical.theta > (min + max) / 2) ?\n                            Math.max(min, spherical.theta) :\n                            Math.min(max, spherical.theta);\n\n                    }\n\n                }\n\n                // restrict phi to be between desired limits\n                spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n\n                spherical.makeSafe();\n\n\n                spherical.radius *= scale;\n\n                // restrict radius to be between desired limits\n                spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));\n\n                // move target to panned location\n\n                if (scope.enableDamping === true) {\n\n                    scope.target.addScaledVector(panOffset, scope.dampingFactor);\n\n                } else {\n\n                    scope.target.add(panOffset);\n\n                }\n\n                offset.setFromSpherical(spherical);\n\n                // rotate offset back to \"camera-up-vector-is-up\" space\n                offset.applyQuaternion(quatInverse);\n\n                position.copy(scope.target).add(offset);\n\n                scope.object.lookAt(scope.target);\n\n                if (scope.enableDamping === true) {\n\n                    sphericalDelta.theta *= (1 - scope.dampingFactor);\n                    sphericalDelta.phi *= (1 - scope.dampingFactor);\n\n                    panOffset.multiplyScalar(1 - scope.dampingFactor);\n\n                } else {\n\n                    sphericalDelta.set(0, 0, 0);\n\n                    panOffset.set(0, 0, 0);\n\n                }\n\n                scale = 1;\n\n                // update condition is:\n                // min(camera displacement, camera rotation in radians)^2 > EPS\n                // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n                if (zoomChanged ||\n                    lastPosition.distanceToSquared(scope.object.position) > EPS ||\n                    8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n\n                    scope.dispatchEvent(_changeEvent);\n\n                    lastPosition.copy(scope.object.position);\n                    lastQuaternion.copy(scope.object.quaternion);\n                    zoomChanged = false;\n\n                    return true;\n\n                }\n\n                return false;\n\n            };\n\n        }();\n\n        this.dispose = function () {\n\n            scope.domElement.removeEventListener('contextmenu', onContextMenu);\n\n            scope.domElement.removeEventListener('pointerdown', onPointerDown);\n            scope.domElement.removeEventListener('wheel', onMouseWheel);\n\n            scope.domElement.removeEventListener('touchstart', onTouchStart);\n            scope.domElement.removeEventListener('touchend', onTouchEnd);\n            scope.domElement.removeEventListener('touchmove', onTouchMove);\n\n            scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove);\n            scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\n\n\n            if (scope._domElementKeyEvents !== null) {\n\n                scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown);\n\n            }\n\n            //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n        };\n\n        //\n        // internals\n        //\n\n        const scope = this;\n\n        const STATE = {\n            NONE: - 1,\n            ROTATE: 0,\n            DOLLY: 1,\n            PAN: 2,\n            TOUCH_ROTATE: 3,\n            TOUCH_PAN: 4,\n            TOUCH_DOLLY_PAN: 5,\n            TOUCH_DOLLY_ROTATE: 6\n        };\n\n        let state = STATE.NONE;\n\n        const EPS = 0.000001;\n\n        // current position in spherical coordinates\n        const spherical = new Spherical();\n        const sphericalDelta = new Spherical();\n\n        let scale = 1;\n        const panOffset = new Vector3();\n        let zoomChanged = false;\n\n        const rotateStart = new Vector2();\n        const rotateEnd = new Vector2();\n        const rotateDelta = new Vector2();\n\n        const panStart = new Vector2();\n        const panEnd = new Vector2();\n        const panDelta = new Vector2();\n\n        const dollyStart = new Vector2();\n        const dollyEnd = new Vector2();\n        const dollyDelta = new Vector2();\n\n        function getAutoRotationAngle() {\n\n            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n        }\n\n        function getZoomScale() {\n\n            return Math.pow(0.95, scope.zoomSpeed);\n\n        }\n\n        function rotateLeft(angle) {\n\n            sphericalDelta.theta -= angle;\n\n        }\n\n        function rotateUp(angle) {\n\n            sphericalDelta.phi -= angle;\n\n        }\n\n        const panLeft = function () {\n\n            const v = new Vector3();\n\n            return function panLeft(distance, objectMatrix) {\n\n                v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n                v.multiplyScalar(- distance);\n\n                panOffset.add(v);\n\n            };\n\n        }();\n\n        const panUp = function () {\n\n            const v = new Vector3();\n\n            return function panUp(distance, objectMatrix) {\n\n                if (scope.screenSpacePanning === true) {\n\n                    v.setFromMatrixColumn(objectMatrix, 1);\n\n                } else {\n\n                    v.setFromMatrixColumn(objectMatrix, 0);\n                    v.crossVectors(scope.object.up, v);\n\n                }\n\n                v.multiplyScalar(distance);\n\n                panOffset.add(v);\n\n            };\n\n        }();\n\n        // deltaX and deltaY are in pixels; right and down are positive\n        const pan = function () {\n\n            const offset = new Vector3();\n\n            return function pan(deltaX, deltaY) {\n\n                const element = scope.domElement;\n\n                if (scope.object.isPerspectiveCamera) {\n\n                    // perspective\n                    const position = scope.object.position;\n                    offset.copy(position).sub(scope.target);\n                    let targetDistance = offset.length();\n\n                    // half of the fov is center to top of screen\n                    targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);\n\n                    // we use only clientHeight here so aspect ratio does not distort speed\n                    panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n                    panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n\n                } else if (scope.object.isOrthographicCamera) {\n\n                    // orthographic\n                    panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);\n                    panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);\n\n                } else {\n\n                    // camera neither orthographic nor perspective\n                    console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n                    scope.enablePan = false;\n\n                }\n\n            };\n\n        }();\n\n        function dollyOut(dollyScale) {\n\n            if (scope.object.isPerspectiveCamera) {\n\n                scale /= dollyScale;\n\n            } else if (scope.object.isOrthographicCamera) {\n\n                scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));\n                scope.object.updateProjectionMatrix();\n                zoomChanged = true;\n\n            } else {\n\n                console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n                scope.enableZoom = false;\n\n            }\n\n        }\n\n        function dollyIn(dollyScale) {\n\n            if (scope.object.isPerspectiveCamera) {\n\n                scale *= dollyScale;\n\n            } else if (scope.object.isOrthographicCamera) {\n\n                scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));\n                scope.object.updateProjectionMatrix();\n                zoomChanged = true;\n\n            } else {\n\n                console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n                scope.enableZoom = false;\n\n            }\n\n        }\n\n        //\n        // event callbacks - update the object state\n        //\n\n        function handleMouseDownRotate(event) {\n\n            rotateStart.set(event.clientX, event.clientY);\n\n        }\n\n        function handleMouseDownDolly(event) {\n\n            dollyStart.set(event.clientX, event.clientY);\n\n        }\n\n        function handleMouseDownPan(event) {\n\n            panStart.set(event.clientX, event.clientY);\n\n        }\n\n        function handleMouseMoveRotate(event) {\n\n            rotateEnd.set(event.clientX, event.clientY);\n\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n\n            const element = scope.domElement;\n\n            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n\n            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n\n            rotateStart.copy(rotateEnd);\n\n            scope.update();\n\n        }\n\n        function handleMouseMoveDolly(event) {\n\n            dollyEnd.set(event.clientX, event.clientY);\n\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n\n            if (dollyDelta.y > 0) {\n\n                dollyOut(getZoomScale());\n\n            } else if (dollyDelta.y < 0) {\n\n                dollyIn(getZoomScale());\n\n            }\n\n            dollyStart.copy(dollyEnd);\n\n            scope.update();\n\n        }\n\n        function handleMouseMovePan(event) {\n\n            panEnd.set(event.clientX, event.clientY);\n\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n            pan(panDelta.x, panDelta.y);\n\n            panStart.copy(panEnd);\n\n            scope.update();\n\n        }\n\n        function handleMouseUp( /*event*/) {\n\n            // no-op\n\n        }\n\n        function handleMouseWheel(event) {\n\n            if (event.deltaY < 0) {\n\n                dollyIn(getZoomScale());\n\n            } else if (event.deltaY > 0) {\n\n                dollyOut(getZoomScale());\n\n            }\n\n            scope.update();\n\n        }\n\n        function handleKeyDown(event) {\n\n            let needsUpdate = false;\n\n            switch (event.code) {\n\n                case scope.keys.UP:\n                    pan(0, scope.keyPanSpeed);\n                    needsUpdate = true;\n                    break;\n\n                case scope.keys.BOTTOM:\n                    pan(0, - scope.keyPanSpeed);\n                    needsUpdate = true;\n                    break;\n\n                case scope.keys.LEFT:\n                    pan(scope.keyPanSpeed, 0);\n                    needsUpdate = true;\n                    break;\n\n                case scope.keys.RIGHT:\n                    pan(- scope.keyPanSpeed, 0);\n                    needsUpdate = true;\n                    break;\n\n            }\n\n            if (needsUpdate) {\n\n                // prevent the browser from scrolling on cursor keys\n                event.preventDefault();\n\n                scope.update();\n\n            }\n\n\n        }\n\n        function handleTouchStartRotate(event) {\n\n            if (event.touches.length == 1) {\n\n                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\n            } else {\n\n                const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n                const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n                rotateStart.set(x, y);\n\n            }\n\n        }\n\n        function handleTouchStartPan(event) {\n\n            if (event.touches.length == 1) {\n\n                panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\n            } else {\n\n                const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n                const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n                panStart.set(x, y);\n\n            }\n\n        }\n\n        function handleTouchStartDolly(event) {\n\n            const dx = event.touches[0].pageX - event.touches[1].pageX;\n            const dy = event.touches[0].pageY - event.touches[1].pageY;\n\n            const distance = Math.sqrt(dx * dx + dy * dy);\n\n            dollyStart.set(0, distance);\n\n        }\n\n        function handleTouchStartDollyPan(event) {\n\n            if (scope.enableZoom) handleTouchStartDolly(event);\n\n            if (scope.enablePan) handleTouchStartPan(event);\n\n        }\n\n        function handleTouchStartDollyRotate(event) {\n\n            if (scope.enableZoom) handleTouchStartDolly(event);\n\n            if (scope.enableRotate) handleTouchStartRotate(event);\n\n        }\n\n        function handleTouchMoveRotate(event) {\n\n            if (event.touches.length == 1) {\n\n                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n\n            } else {\n\n                const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n                const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n                rotateEnd.set(x, y);\n\n            }\n\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n\n            const element = scope.domElement;\n\n            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n\n            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n\n            rotateStart.copy(rotateEnd);\n\n        }\n\n        function handleTouchMovePan(event) {\n\n            if (event.touches.length == 1) {\n\n                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n\n            } else {\n\n                const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n                const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n                panEnd.set(x, y);\n\n            }\n\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n            pan(panDelta.x, panDelta.y);\n\n            panStart.copy(panEnd);\n\n        }\n\n        function handleTouchMoveDolly(event) {\n\n            const dx = event.touches[0].pageX - event.touches[1].pageX;\n            const dy = event.touches[0].pageY - event.touches[1].pageY;\n\n            const distance = Math.sqrt(dx * dx + dy * dy);\n\n            dollyEnd.set(0, distance);\n\n            dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n\n            dollyOut(dollyDelta.y);\n\n            dollyStart.copy(dollyEnd);\n\n        }\n\n        function handleTouchMoveDollyPan(event) {\n\n            if (scope.enableZoom) handleTouchMoveDolly(event);\n\n            if (scope.enablePan) handleTouchMovePan(event);\n\n        }\n\n        function handleTouchMoveDollyRotate(event) {\n\n            if (scope.enableZoom) handleTouchMoveDolly(event);\n\n            if (scope.enableRotate) handleTouchMoveRotate(event);\n\n        }\n\n        function handleTouchEnd( /*event*/) {\n\n            // no-op\n\n        }\n\n        //\n        // event handlers - FSM: listen for events and reset state\n        //\n\n        function onPointerDown(event) {\n\n            if (scope.enabled === false) return;\n\n            switch (event.pointerType) {\n\n                case 'mouse':\n                case 'pen':\n                    onMouseDown(event);\n                    break;\n\n                // TODO touch\n\n            }\n\n        }\n\n        function onPointerMove(event) {\n\n            if (scope.enabled === false) return;\n\n            switch (event.pointerType) {\n\n                case 'mouse':\n                case 'pen':\n                    onMouseMove(event);\n                    break;\n\n                // TODO touch\n\n            }\n\n        }\n\n        function onPointerUp(event) {\n\n            switch (event.pointerType) {\n\n                case 'mouse':\n                case 'pen':\n                    onMouseUp(event);\n                    break;\n\n                // TODO touch\n\n            }\n\n        }\n\n        function onMouseDown(event) {\n\n            // Prevent the browser from scrolling.\n            event.preventDefault();\n\n            // Manually set the focus since calling preventDefault above\n            // prevents the browser from setting it automatically.\n\n            scope.domElement.focus ? scope.domElement.focus() : window.focus();\n\n            let mouseAction;\n\n            switch (event.button) {\n\n                case 0:\n\n                    mouseAction = scope.mouseButtons.LEFT;\n                    break;\n\n                case 1:\n\n                    mouseAction = scope.mouseButtons.MIDDLE;\n                    break;\n\n                case 2:\n\n                    mouseAction = scope.mouseButtons.RIGHT;\n                    break;\n\n                default:\n\n                    mouseAction = - 1;\n\n            }\n\n            switch (mouseAction) {\n\n                case MOUSE.DOLLY:\n\n                    if (scope.enableZoom === false) return;\n\n                    handleMouseDownDolly(event);\n\n                    state = STATE.DOLLY;\n\n                    break;\n\n                case MOUSE.ROTATE:\n\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n\n                        if (scope.enablePan === false) return;\n\n                        handleMouseDownPan(event);\n\n                        state = STATE.PAN;\n\n                    } else {\n\n                        if (scope.enableRotate === false) return;\n\n                        handleMouseDownRotate(event);\n\n                        state = STATE.ROTATE;\n\n                    }\n\n                    break;\n\n                case MOUSE.PAN:\n\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n\n                        if (scope.enableRotate === false) return;\n\n                        handleMouseDownRotate(event);\n\n                        state = STATE.ROTATE;\n\n                    } else {\n\n                        if (scope.enablePan === false) return;\n\n                        handleMouseDownPan(event);\n\n                        state = STATE.PAN;\n\n                    }\n\n                    break;\n\n                default:\n\n                    state = STATE.NONE;\n\n            }\n\n            if (state !== STATE.NONE) {\n\n                scope.domElement.ownerDocument.addEventListener('pointermove', onPointerMove);\n                scope.domElement.ownerDocument.addEventListener('pointerup', onPointerUp);\n\n                scope.dispatchEvent(_startEvent);\n\n            }\n\n        }\n\n        function onMouseMove(event) {\n\n            if (scope.enabled === false) return;\n\n            event.preventDefault();\n\n            switch (state) {\n\n                case STATE.ROTATE:\n\n                    if (scope.enableRotate === false) return;\n\n                    handleMouseMoveRotate(event);\n\n                    break;\n\n                case STATE.DOLLY:\n\n                    if (scope.enableZoom === false) return;\n\n                    handleMouseMoveDolly(event);\n\n                    break;\n\n                case STATE.PAN:\n\n                    if (scope.enablePan === false) return;\n\n                    handleMouseMovePan(event);\n\n                    break;\n\n            }\n\n        }\n\n        function onMouseUp(event) {\n\n            scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove);\n            scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\n\n            if (scope.enabled === false) return;\n\n            handleMouseUp(event);\n\n            scope.dispatchEvent(_endEvent);\n\n            state = STATE.NONE;\n\n        }\n\n        function onMouseWheel(event) {\n\n            if (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE)) return;\n\n            event.preventDefault();\n\n            scope.dispatchEvent(_startEvent);\n\n            handleMouseWheel(event);\n\n            scope.dispatchEvent(_endEvent);\n\n        }\n\n        function onKeyDown(event) {\n\n            if (scope.enabled === false || scope.enablePan === false) return;\n\n            handleKeyDown(event);\n\n        }\n\n        function onTouchStart(event) {\n\n            if (scope.enabled === false) return;\n\n            event.preventDefault(); // prevent scrolling\n\n            switch (event.touches.length) {\n\n                case 1:\n\n                    switch (scope.touches.ONE) {\n\n                        case TOUCH.ROTATE:\n\n                            if (scope.enableRotate === false) return;\n\n                            handleTouchStartRotate(event);\n\n                            state = STATE.TOUCH_ROTATE;\n\n                            break;\n\n                        case TOUCH.PAN:\n\n                            if (scope.enablePan === false) return;\n\n                            handleTouchStartPan(event);\n\n                            state = STATE.TOUCH_PAN;\n\n                            break;\n\n                        default:\n\n                            state = STATE.NONE;\n\n                    }\n\n                    break;\n\n                case 2:\n\n                    switch (scope.touches.TWO) {\n\n                        case TOUCH.DOLLY_PAN:\n\n                            if (scope.enableZoom === false && scope.enablePan === false) return;\n\n                            handleTouchStartDollyPan(event);\n\n                            state = STATE.TOUCH_DOLLY_PAN;\n\n                            break;\n\n                        case TOUCH.DOLLY_ROTATE:\n\n                            if (scope.enableZoom === false && scope.enableRotate === false) return;\n\n                            handleTouchStartDollyRotate(event);\n\n                            state = STATE.TOUCH_DOLLY_ROTATE;\n\n                            break;\n\n                        default:\n\n                            state = STATE.NONE;\n\n                    }\n\n                    break;\n\n                default:\n\n                    state = STATE.NONE;\n\n            }\n\n            if (state !== STATE.NONE) {\n\n                scope.dispatchEvent(_startEvent);\n\n            }\n\n        }\n\n        function onTouchMove(event) {\n\n            if (scope.enabled === false) return;\n\n            event.preventDefault(); // prevent scrolling\n\n            switch (state) {\n\n                case STATE.TOUCH_ROTATE:\n\n                    if (scope.enableRotate === false) return;\n\n                    handleTouchMoveRotate(event);\n\n                    scope.update();\n\n                    break;\n\n                case STATE.TOUCH_PAN:\n\n                    if (scope.enablePan === false) return;\n\n                    handleTouchMovePan(event);\n\n                    scope.update();\n\n                    break;\n\n                case STATE.TOUCH_DOLLY_PAN:\n\n                    if (scope.enableZoom === false && scope.enablePan === false) return;\n\n                    handleTouchMoveDollyPan(event);\n\n                    scope.update();\n\n                    break;\n\n                case STATE.TOUCH_DOLLY_ROTATE:\n\n                    if (scope.enableZoom === false && scope.enableRotate === false) return;\n\n                    handleTouchMoveDollyRotate(event);\n\n                    scope.update();\n\n                    break;\n\n                default:\n\n                    state = STATE.NONE;\n\n            }\n\n        }\n\n        function onTouchEnd(event) {\n\n            if (scope.enabled === false) return;\n\n            handleTouchEnd(event);\n\n            scope.dispatchEvent(_endEvent);\n\n            state = STATE.NONE;\n\n        }\n\n        function onContextMenu(event) {\n\n            if (scope.enabled === false) return;\n\n            event.preventDefault();\n\n        }\n\n        //\n\n        scope.domElement.addEventListener('contextmenu', onContextMenu);\n\n        scope.domElement.addEventListener('pointerdown', onPointerDown);\n        scope.domElement.addEventListener('wheel', onMouseWheel, { passive: false });\n\n        scope.domElement.addEventListener('touchstart', onTouchStart, { passive: false });\n        scope.domElement.addEventListener('touchend', onTouchEnd);\n        scope.domElement.addEventListener('touchmove', onTouchMove, { passive: false });\n\n        // force an update at start\n\n        this.update();\n\n    }\n\n}\n\n\nconsole.log('hello');\nconsole.log(dat);\n\nconst raycaster = new THREE.Raycaster()\nconst scene = new THREE.Scene()\nconst camera = new THREE.PerspectiveCamera(\n    75,\n    innerWidth / innerHeight,\n    0.1,\n    1000\n)\nconst renderer = new THREE.WebGLRenderer()\n\n\nrenderer.setSize(innerWidth, innerHeight)\nrenderer.setPixelRatio(devicePixelRatio)\n\nfunction generatePlane() {\n    planeMesh.geometry.dispose()\n    planeMesh.geometry = new THREE.PlaneGeometry(\n        world.plane.width,\n        world.plane.height,\n        world.plane.widthSegments,\n        world.plane.heightSegments\n    )\n\n    // vertices position randomization\n    const { array } = planeMesh.geometry.attributes.position\n    const randomValues = []\n    for (let i = 0; i < array.length; i++) {\n        if (i % 3 === 0) {\n            const x = array[i]\n            const y = array[i + 1]\n            const z = array[i + 2]\n\n            array[i] = x + (Math.random() - 0.5) * 3\n            array[i + 1] = y + (Math.random() - 0.5) * 3\n            array[i + 2] = z + Math.random() * 3\n        }\n        randomValues.push(Math.random() * Math.PI * 2)\n    }\n\n    planeMesh.geometry.attributes.position.randomValues = randomValues\n    planeMesh.geometry.attributes.position.originalPosition =\n        planeMesh.geometry.attributes.position.array\n\n    // color attribute addition\n    const colors = []\n    for (let i = 0; i < planeMesh.geometry.attributes.position.count; i++) {\n        colors.push(0, 0.19, 0.4)\n    }\n\n    planeMesh.geometry.setAttribute('color',\n        new THREE.BufferAttribute(new Float32Array(colors), 3)\n    )\n}\n\nconst gui = new dat.GUI()\nconst world = {\n    plane: {\n        width: 400,\n        height: 400,\n        widthSegments: 50,\n        heightSegments: 50\n    }\n}\n\ngui.add(world.plane, 'width', 1, 500).onChange(generatePlane)\ngui.add(world.plane, 'height', 1, 500).onChange(generatePlane)\ngui.add(world.plane, 'widthSegments', 1, 100).onChange(generatePlane)\ngui.add(world.plane, 'heightSegments', 1, 100).onChange(generatePlane)\n\ndocument.body.appendChild(renderer.domElement)\n\nconst controls = new OrbitControls(camera, renderer.domElement)\nconsole.log(controls, 'now');\n// const boxGeometry = new THREE.BoxGeometry(1, 1, 1)\n// const material = new THREE.MeshBasicMaterial({color: 0x00FF00})\n// const mesh = new THREE.Mesh(boxGeometry, material)\n// scene.add(mesh)\n\ncamera.position.z = 50\n\nconst planeGeometry = new THREE.PlaneGeometry(\n    world.plane.width,\n    world.plane.height,\n    world.plane.widthSegments,\n    world.plane.heightSegments)\n\nconst planeMaterial = new THREE.MeshPhongMaterial({\n    // color: 0xff0000,\n    side: THREE.DoubleSide,\n    flatShading: THREE.FlatShading,\n    vertexColors: true\n})\nconst planeMesh = new THREE.Mesh(planeGeometry, planeMaterial)\nscene.add(planeMesh)\ngeneratePlane()\n\n\nconst light = new THREE.DirectionalLight(0xffffff, 1)\nlight.position.set(0, -1, 1)\nscene.add(light)\n\nconst backlight = new THREE.DirectionalLight(0xffffff, 1)\nbacklight.position.set(0, 0, -1)\nscene.add(backlight)\n\nconst mouse = {\n    x: undefined,\n    y: undefined\n}\n\nlet frame = 0\nfunction animate() {\n    requestAnimationFrame(animate)\n    renderer.render(scene, camera)\n    raycaster.setFromCamera(mouse, camera)\n    frame += 0.01\n\n    const {\n        array,\n        originalPosition,\n        randomValues\n    } = planeMesh.geometry.attributes.position\n    for (let i = 0; i < array.length; i += 3) {\n        // x\n        array[i] = originalPosition[i] +\n            Math.cos(frame + randomValues[i]) * 0.01\n\n        // y\n        array[i + 1] = originalPosition[i + 1] +\n            Math.sin(frame + randomValues[i + 1]) * 0.001\n    }\n\n    planeMesh.geometry.attributes.position.needsUpdate = true\n\n    const intersects = raycaster.intersectObject(planeMesh)\n    if (intersects.length > 0) {\n        const { color } = intersects[0].object.geometry.attributes\n\n        // vertices 1\n        color.setX(intersects[0].face.a, 0.1)\n        color.setY(intersects[0].face.b, 0.5)\n        color.setZ(intersects[0].face.b, 1)\n\n        // vertices 2\n        color.setX(intersects[0].face.c, 0.1)\n        color.setY(intersects[0].face.c, 0.5)\n        color.setZ(intersects[0].face.c, 1)\n\n        // vertices 3\n        color.setX(intersects[0].face.c, 0.1)\n        color.setY(intersects[0].face.c, 0.5)\n        color.setZ(intersects[0].face.c, 1)\n\n        color.needsUpdate = true\n        // changes back to original color\n        const initialColor = {\n            r: 0,\n            g: 0.19,\n            b: 0.4\n        }\n\n        const hoverColor = {\n            r: 0.1,\n            g: 0.5,\n            b: 1\n        }\n        gsap.to(hoverColor, {\n            r: initialColor.r,\n            g: initialColor.g,\n            b: initialColor.b,\n            duration: 1,\n            onUpdate: () => {\n                // vertices 1\n                color.setX(intersects[0].face.a, hoverColor.r)\n                color.setY(intersects[0].face.a, hoverColor.g)\n                color.setZ(intersects[0].face.a, hoverColor.b)\n\n                // vertices 2\n                color.setX(intersects[0].face.b, hoverColor.r)\n                color.setY(intersects[0].face.b, hoverColor.g)\n                color.setZ(intersects[0].face.b, hoverColor.b)\n\n                // vertices 3\n                color.setX(intersects[0].face.c, hoverColor.r)\n                color.setY(intersects[0].face.c, hoverColor.g)\n                color.setZ(intersects[0].face.c, hoverColor.b)\n                color.needsUpdate = true\n\n            }\n        })\n    }\n    // mesh.rotation.x += 0.01\n    // mesh.rotation.y += 0.01\n    // planeMesh.rotation.x += 0.01\n\n}\n\nrenderer.render(scene, camera)\n\nanimate()\naddEventListener('mousemove', (event) => {\n    mouse.x = (event.clientX / innerWidth) * 2 - 1\n    mouse.y = -(event.clientY / innerHeight) * 2 + 1\n})\n"]}